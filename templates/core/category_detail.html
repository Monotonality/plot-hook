{% extends 'base.html' %}

{% block title %}{{ category.name }} - {{ world.name }}{% endblock %}
{% block page_title %}{{ category.name }}{% endblock %}
{% block main_title %}{{ category.name }}{% endblock %}

{% block content %}
<div class="content-section">
    <!-- Breadcrumb navigation -->
    <nav class="breadcrumb-nav">
        <a href="{% url 'core:world_list' %}">Worlds</a> &gt;
        <a href="{% url 'core:world_detail' world.id %}">{{ world.name }}</a>
        {% for ancestor in ancestors %}
            &gt; <a href="{% url 'core:category_detail' world.id ancestor.id %}">{{ ancestor.name }}</a>
        {% endfor %}
        &gt; {{ category.name }}
    </nav>
    
    <div class="category-header">
        <h1 class="section-title">{{ category.name }}</h1>
        {% if category.description %}
            <p class="category-description">{{ category.description }}</p>
        {% endif %}
    </div>
    
    {% if subcategories %}
        <h2 class="section-title">Subcategories</h2>
        <div class="campaigns-grid">
            {% for subcategory in subcategories %}
                <div class="campaign-card category-card">
                    <div class="campaign-pattern pattern-indigo">
                        <div class="campaign-badge badge-indigo">{{ subcategory.name|slice:":3"|upper }}</div>
                    </div>
                    <div class="campaign-info">
                        <div class="campaign-title">{{ subcategory.name }}</div>
                        <div class="campaign-stats">{{ subcategory.description|truncatewords:15 }}</div>
                        <div class="campaign-actions">
                            <a href="{% url 'core:category_detail' world.id subcategory.id %}" class="campaign-link">View</a>
                            <button class="campaign-menu">‚ãÆ</button>
                        </div>
                    </div>
                </div>
            {% endfor %}
        </div>
    {% endif %}
    
    <div class="content-section">
        <h2 class="section-title">Entries</h2>
        <div class="empty-state">
            <div class="empty-icon">üìù</div>
            <div class="empty-title">No Entries Yet</div>
            <div class="empty-text">Entries will be displayed here once we implement the Entry model.</div>
        </div>
    </div>
    
    <div class="create-card">
        <div class="create-icon">+</div>
        <div class="create-text">Create New Entry</div>
    </div>
</div>

<style>
.breadcrumb-nav {
    margin-bottom: 20px;
    padding: 15px 0;
    border-bottom: 1px solid #404040;
    font-size: 0.9rem;
}

.breadcrumb-nav a {
    color: #8b7355;
    text-decoration: none;
    transition: color 0.3s ease;
}

.breadcrumb-nav a:hover {
    color: #e8e6e3;
    text-decoration: underline;
}

.category-header {
    margin-bottom: 30px;
    padding: 25px;
    background: #202020;
    border-radius: 8px;
    border: 1px solid #404040;
}

.category-description {
    font-size: 1.1em;
    color: #a0a0a0;
    margin: 15px 0;
    line-height: 1.6;
}

.category-card {
    cursor: pointer;
}

.category-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
}

.pattern-indigo {
    background: linear-gradient(45deg, #6366f1 25%, transparent 25%), 
                linear-gradient(-45deg, #6366f1 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #6366f1 75%), 
                linear-gradient(-45deg, transparent 75%, #6366f1 75%);
    background-size: 20px 20px;
    background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
}

.badge-indigo {
    background: #6366f1;
}

.empty-state {
    grid-column: 1 / -1;
    text-align: center;
    padding: 40px 20px;
    background: #202020;
    border-radius: 8px;
    border: 2px dashed #404040;
    margin-bottom: 20px;
}

.empty-icon {
    font-size: 3rem;
    margin-bottom: 15px;
}

.empty-title {
    font-size: 1.2rem;
    font-weight: 600;
    color: #e8e6e3;
    margin-bottom: 8px;
}

.empty-text {
    color: #a0a0a0;
    font-size: 0.9rem;
    max-width: 400px;
    margin: 0 auto;
}

.create-card {
    background: #303030;
    border: 2px dashed #505050;
    border-radius: 8px;
    height: 200px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s ease;
}

.create-card:hover {
    border-color: #8b7355;
    background: #383838;
}

.create-icon {
    font-size: 2rem;
    color: #a0a0a0;
    margin-bottom: 10px;
}

.create-text {
    color: #a0a0a0;
    font-size: 0.9rem;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Initialize animated background for category detail page
    initializeAnimatedBackground();
    
    // Initialize category card interactions
    initializeCategoryCards();
});

function initializeCategoryCards() {
    const categoryCards = document.querySelectorAll('.category-card');
    const createCard = document.querySelector('.create-card');
    
    categoryCards.forEach(card => {
        card.addEventListener('click', function(e) {
            // Don't navigate if clicking on menu button
            if (e.target.closest('.campaign-menu')) {
                return;
            }
            
            const link = this.querySelector('.campaign-link');
            if (link) {
                window.location.href = link.href;
            }
        });
        
        // Handle menu button clicks (for future functionality)
        const menuButton = card.querySelector('.campaign-menu');
        if (menuButton) {
            menuButton.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent card click
                console.log('Category menu clicked');
                // Add category menu functionality here
            });
        }
    });
    
    if (createCard) {
        createCard.addEventListener('click', function() {
            console.log('Create new entry clicked');
            // Add create entry logic here
        });
    }
}

function initializeAnimatedBackground() {
    const mainContent = document.querySelector('.main-content');
    if (!mainContent) return;
    
    // Create canvas for particle system
    const canvas = document.createElement('canvas');
    canvas.className = 'particle-canvas';
    canvas.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 0;
    `;
    
    // Insert canvas before the first child
    mainContent.insertBefore(canvas, mainContent.firstChild);
    
    const ctx = canvas.getContext('2d');
    
    // Set canvas size
    function resizeCanvas() {
        canvas.width = mainContent.offsetWidth;
        canvas.height = mainContent.offsetHeight;
    }
    
    // Function to create a new particle
    function createParticle() {
        const size = Math.random() * 1.0 + 0.15; // 0.15 to 1.15 pixels
        const opacity = Math.random() * 0.15 + 0.025; // 0.025 to 0.175
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        
        return new Particle(x, y, size, opacity);
    }
    
    // Function to add particles if needed after resize
    function addParticlesIfNeeded() {
        const currentArea = canvas.width * canvas.height;
        const targetParticleDensity = 0.0001; // particles per pixel
        const targetParticleCount = Math.floor(currentArea * targetParticleDensity);
        
        // Reposition existing particles to fill the new canvas area
        particles.forEach(particle => {
            particle.x = Math.random() * canvas.width;
            particle.y = Math.random() * canvas.height;
        });
        
        // Add particles if we have fewer than the target
        while (particles.length < targetParticleCount) {
            particles.push(createParticle());
        }
    }
    
    resizeCanvas();
    window.addEventListener('resize', () => {
        resizeCanvas();
        addParticlesIfNeeded();
    });
    
    // Particle class
    class Particle {
        constructor(x, y, size, opacity) {
            this.x = x;
            this.y = y;
            this.size = size;
            this.opacity = opacity;
            this.vx = (Math.random() - 0.5) * 0.6; // Increased velocity X (-0.3 to 0.3)
            this.vy = (Math.random() - 0.5) * 0.6; // Increased velocity Y (-0.3 to 0.3)
            this.originalSize = size;
            this.originalOpacity = opacity;
        }
        
        update() {
            // Update position
            this.x += this.vx;
            this.y += this.vy;
            
            // Bounce off walls
            if (this.x <= this.size || this.x >= canvas.width - this.size) {
                this.vx = -this.vx;
                this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
            }
            
            if (this.y <= this.size || this.y >= canvas.height - this.size) {
                this.vy = -this.vy;
                this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));
            }
            
            // Add slight random movement
            this.vx += (Math.random() - 0.5) * 0.01;
            this.vy += (Math.random() - 0.5) * 0.01;
            
            // Limit velocity
            this.vx = Math.max(-0.8, Math.min(0.8, this.vx));
            this.vy = Math.max(-0.8, Math.min(0.8, this.vy));
        }
        
        draw() {
            ctx.save();
            ctx.globalAlpha = this.opacity;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        
        // Check collision with another particle
        collidesWith(other) {
            const dx = this.x - other.x;
            const dy = this.y - other.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (this.size + other.size);
        }
        
        // Handle collision
        handleCollision(other) {
            const dx = this.x - other.x;
            const dy = this.y - other.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance === 0) return;
            
            // Normalize
            const nx = dx / distance;
            const ny = dy / distance;
            
            // Relative velocity
            const relativeVelocityX = this.vx - other.vx;
            const relativeVelocityY = this.vy - other.vy;
            
            // Calculate impulse
            const speed = relativeVelocityX * nx + relativeVelocityY * ny;
            
            if (speed < 0) return; // Already moving apart
            
            // Elastic collision
            const impulse = 2 * speed / (this.size + other.size);
            
            this.vx -= impulse * other.size * nx;
            this.vy -= impulse * other.size * ny;
            other.vx += impulse * this.size * nx;
            other.vy += impulse * this.size * ny;
            
            // Separate particles to prevent sticking
            const overlap = (this.size + other.size) - distance;
            const separationX = nx * overlap * 0.5;
            const separationY = ny * overlap * 0.5;
            
            this.x += separationX;
            this.y += separationY;
            other.x -= separationX;
            other.y -= separationY;
        }
    }
    
    // Create particles with varying sizes and opacities
    const particles = [];
    
    // Initial particle creation
    for (let i = 0; i < 500; i++) {
        particles.push(createParticle());
    }
    
    // Animation loop
    function animate() {
        // Clear canvas with darker background
        ctx.fillStyle = '#1a1a1a'; // Darker background for better particle visibility
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Update and draw particles
        for (let i = 0; i < particles.length; i++) {
            particles[i].update();
            particles[i].draw();
            
            // Check collisions with other particles
            for (let j = i + 1; j < particles.length; j++) {
                if (particles[i].collidesWith(particles[j])) {
                    particles[i].handleCollision(particles[j]);
                }
            }
        }
        
        requestAnimationFrame(animate);
    }
    
    // Start animation
    animate();
}
</script>
{% endblock %}
